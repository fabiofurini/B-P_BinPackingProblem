

#include "DP.h"

double f[100001];
double g[100001];
int J[100001][1100];

double EPSILON_DP_F;
double EPSILON_DP_G;

#define TOLL_TIES 1E-6


/*****************************************************************************/
double DP_kp01_advanced(int n, int C, double* p, int* w,double *sol,bool MAXIMALITY,int* order)
/*****************************************************************************/
{

	int s, j,jj,jjj;

	for(s = 0; s <= C; s++) {f[s] = 0;}
	//for(s = 0; s <= C; s++){{for(j = 0; j < n; j++)J[s][j]=0;}}

	///////////////////////////////////////////////////////////////////////////////////////////////////
	//for each item
	for (jjj = 0; jjj < n; jjj++)
	{
		int j=order[jjj];

		//for each value of capacity
		for (s = C; s >= w[j]; s--)
		{
			J[s][j]=0;

			//improving solution
			if (p[j] + f[ s-w[j] ] - f[s] > TOLL_TIES)
			{

				f[s] = p[j] + f[ s-w[j] ];

				J[s][j]=1;
			}

			////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			//ties
			if(MAXIMALITY)
			{
				if
				(
						( p[j] + f[ s-w[j] ] - f[s] > -TOLL_TIES)
						&&
						( p[j] + f[ s-w[j] ] - f[s] < TOLL_TIES)
				)
				{

					f[s] = p[j] + f[ s-w[j] ];

					J[s][j]=1;
				}
			}
			////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


		}
	}
	///////////////////////////////////////////////////////////////////////////////////////////////////


	int c=C;
	for (jjj = n-1; jjj >= 0; jjj--)
	{
		j=order[jjj];
		if(J[c][j]==1)
		{
			sol[j]=1;
			c-=w[j];
		}
		else
		{
			sol[j]=0;
		}
	}

	//one can add more than 1 column at each iteration

	return f[C];

}




